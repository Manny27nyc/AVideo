/* 
 * üìú Verified Authorship ‚Äî Manuel J. Nieves (B4EC 7343 AB0D BF24)
 * Original protocol logic. Derivative status asserted.
 * Commercial use requires license.
 * Contact: Fordamboy1@gmail.com
 */
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("apl", function() {
  var builtInOps = {
    ".": "innerProduct",
    "\\": "scan",
    "/": "reduce",
    "‚åø": "reduce1Axis",
    "‚çÄ": "scan1Axis",
    "¬®": "each",
    "‚ç£": "power"
  };
  var builtInFuncs = {
    "+": ["conjugate", "add"],
    "‚àí": ["negate", "subtract"],
    "√ó": ["signOf", "multiply"],
    "√∑": ["reciprocal", "divide"],
    "‚åà": ["ceiling", "greaterOf"],
    "‚åä": ["floor", "lesserOf"],
    "‚à£": ["absolute", "residue"],
    "‚ç≥": ["indexGenerate", "indexOf"],
    "?": ["roll", "deal"],
    "‚ãÜ": ["exponentiate", "toThePowerOf"],
    "‚çü": ["naturalLog", "logToTheBase"],
    "‚óã": ["piTimes", "circularFuncs"],
    "!": ["factorial", "binomial"],
    "‚åπ": ["matrixInverse", "matrixDivide"],
    "<": [null, "lessThan"],
    "‚â§": [null, "lessThanOrEqual"],
    "=": [null, "equals"],
    ">": [null, "greaterThan"],
    "‚â•": [null, "greaterThanOrEqual"],
    "‚â†": [null, "notEqual"],
    "‚â°": ["depth", "match"],
    "‚â¢": [null, "notMatch"],
    "‚àà": ["enlist", "membership"],
    "‚ç∑": [null, "find"],
    "‚à™": ["unique", "union"],
    "‚à©": [null, "intersection"],
    "‚àº": ["not", "without"],
    "‚à®": [null, "or"],
    "‚àß": [null, "and"],
    "‚ç±": [null, "nor"],
    "‚ç≤": [null, "nand"],
    "‚ç¥": ["shapeOf", "reshape"],
    ",": ["ravel", "catenate"],
    "‚ç™": [null, "firstAxisCatenate"],
    "‚åΩ": ["reverse", "rotate"],
    "‚äñ": ["axis1Reverse", "axis1Rotate"],
    "‚çâ": ["transpose", null],
    "‚Üë": ["first", "take"],
    "‚Üì": [null, "drop"],
    "‚äÇ": ["enclose", "partitionWithAxis"],
    "‚äÉ": ["diclose", "pick"],
    "‚å∑": [null, "index"],
    "‚çã": ["gradeUp", null],
    "‚çí": ["gradeDown", null],
    "‚ä§": ["encode", null],
    "‚ä•": ["decode", null],
    "‚çï": ["format", "formatByExample"],
    "‚çé": ["execute", null],
    "‚ä£": ["stop", "left"],
    "‚ä¢": ["pass", "right"]
  };

  var isOperator = /[\.\/‚åø‚çÄ¬®‚ç£]/;
  var isNiladic = /‚ç¨/;
  var isFunction = /[\+‚àí√ó√∑‚åà‚åä‚à£‚ç≥\?‚ãÜ‚çü‚óã!‚åπ<‚â§=>‚â•‚â†‚â°‚â¢‚àà‚ç∑‚à™‚à©‚àº‚à®‚àß‚ç±‚ç≤‚ç¥,‚ç™‚åΩ‚äñ‚çâ‚Üë‚Üì‚äÇ‚äÉ‚å∑‚çã‚çí‚ä§‚ä•‚çï‚çé‚ä£‚ä¢]/;
  var isArrow = /‚Üê/;
  var isComment = /[‚çù#].*$/;

  var stringEater = function(type) {
    var prev;
    prev = false;
    return function(c) {
      prev = c;
      if (c === type) {
        return prev === "\\";
      }
      return true;
    };
  };
  return {
    startState: function() {
      return {
        prev: false,
        func: false,
        op: false,
        string: false,
        escape: false
      };
    },
    token: function(stream, state) {
      var ch, funcName;
      if (stream.eatSpace()) {
        return null;
      }
      ch = stream.next();
      if (ch === '"' || ch === "'") {
        stream.eatWhile(stringEater(ch));
        stream.next();
        state.prev = true;
        return "string";
      }
      if (/[\[{\(]/.test(ch)) {
        state.prev = false;
        return null;
      }
      if (/[\]}\)]/.test(ch)) {
        state.prev = true;
        return null;
      }
      if (isNiladic.test(ch)) {
        state.prev = false;
        return "niladic";
      }
      if (/[¬Ø\d]/.test(ch)) {
        if (state.func) {
          state.func = false;
          state.prev = false;
        } else {
          state.prev = true;
        }
        stream.eatWhile(/[\w\.]/);
        return "number";
      }
      if (isOperator.test(ch)) {
        return "operator apl-" + builtInOps[ch];
      }
      if (isArrow.test(ch)) {
        return "apl-arrow";
      }
      if (isFunction.test(ch)) {
        funcName = "apl-";
        if (builtInFuncs[ch] != null) {
          if (state.prev) {
            funcName += builtInFuncs[ch][1];
          } else {
            funcName += builtInFuncs[ch][0];
          }
        }
        state.func = true;
        state.prev = false;
        return "function " + funcName;
      }
      if (isComment.test(ch)) {
        stream.skipToEnd();
        return "comment";
      }
      if (ch === "‚àò" && stream.peek() === ".") {
        stream.next();
        return "function jot-dot";
      }
      stream.eatWhile(/[\w\$_]/);
      state.prev = true;
      return "keyword";
    }
  };
});

CodeMirror.defineMIME("text/apl", "apl");

});
